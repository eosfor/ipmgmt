function Get-VLSMBreakdown {
    [CmdletBinding()]
    param (
        [Parameter(Mandatory = $true)]
        [ValidateNotNullOrEmpty()]
        [System.Net.IPNetwork]$Network,

        [Parameter(Mandatory = $true)]
        [ValidateNotNullOrEmpty()]
        [array]$SubnetSize
    )

    function processRecord($net, $cidr, $type) {
        try {
            #try breaking down a network block by CIDR in a form of length
            $subnets = @([System.Net.IPNetwork]::Subnet($net, $cidr))

            #if success push the first resulting subnet to output stack and mark them with associated type
            $outStack.Push(($subnets[0] | add-member -MemberType NoteProperty -Name type -Value $type -PassThru -Force))

            #if there are more subnets generated by "subnet" operation
            #returning the rest subnets to the Ip blocks queue fur further processing
            if ($subnets.count -gt 1) {
                for ($i = 1; $i -le $subnets.count - 1; $i++) {
                    $vlsmStack.Enqueue($subnets[$i])
                }
            }
            # return true if "subnetting was successfull"
            $true
        }
        catch {
            # put the network back to the IP blocks queue
            $vlsmStack.Enqueue($net)
            # return true if "subnetting failed"
            $false
        }
    }


    if (($SubnetSize | ForEach-Object {[PSCustomObject]$_} | Measure-Object -Property size -Sum).Sum -lt $Network.Usable) {
        #queue of masks we wnat to use to break our network
        $vlsmMasks = [System.Collections.Queue]::new()

        #calculating mask length based on subnet sizes we get as an input
        #as an output we get list of objects (type; length) sorted by length
        #list is stored in $vlsmMasks variable
        $SubnetSize | ForEach-Object {
            $length = 32 - [math]::Ceiling([math]::Log($_.size + 2, 2))
            [PSCustomObject]@{
                type   = $_.type;
                length = $length
            }
        } | Sort-Object -Property length | ForEach-Object {$vlsmMasks.Enqueue($_)}

        #queue of networks to break down
        $vlsmStack = [System.Collections.Queue]::new()
        #stack of subnets we going to break the network to
        $outStack = [System.Collections.Stack]::new()
        #put the very first network to the queue
        $vlsmStack.Enqueue($Network)

        #at this point we got two queues:
        #masks queue and networks queue
        #masks hosls lengths of all subnets we need and netwoks contains our VNET range (network block)

        do {
            $failureCount = 0
            #pick a msk form a queue
            $v = $vlsmMasks.Dequeue()
            try {
                #pick a network block form a queue
                $current = $vlsmStack.Dequeue()
            }
            catch {
                write-verbose -Message "No networks in the queue to process"
            }

            #processing the block against the mask and assosiated type
            #if no success - return mask back to tail of a queue and increase failue count
            if (! (processRecord $current $v.length $v.type) ) { $vlsmMasks.Enqueue($v); $failureCount++}

            write-verbose ("VLSM MASKS`: " + $vlsmMasks.Count)
            write-verbose ("FAILURES`: " + $failureCount)

            if ($vlsmMasks.Count -eq $failureCount) {break} # break when no records processed during a loop cycle
        } while ($vlsmMasks.Count -ne 0) #leave when we have masks queue emty

        write-verbose ("OUT STACK`: " + $outStack.Count)
        write-verbose ("SubnetSuize`: " + $SubnetSize.count)
        if ($outStack.count -lt $SubnetSize.count) {write-warning -message "subnetting failed"}

        #in case we have more subnets than requested store them
        $reserved = @([System.Net.IPNetwork]::Supernet($vlsmStack.ToArray()))
        $outStack
        #and mark them as 'reserved'
        $reserved | add-member -MemberType NoteProperty -Name type -Value "reserved" -PassThru -Force
    }
}